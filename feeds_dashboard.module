<?php

/**
 * Implements hook_menu().
 */
function feeds_dashboard_menu() {
  $items['import/%feeds_importer/history'] = array(
    'title' => 'History',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'feeds_dashboard_show_history',
    'page arguments' => array(1),
    'access callback' => 'feeds_access',
    'access arguments' => array('import', 1),
    'file' => 'feeds_dashboard.pages.inc',
    'weight' => -9,
  );
  $items['import/%feeds_importer/history/operation/%'] = array(
    'title' => 'Operation',
    'type' => MENU_CALLBACK,
    'page callback' => 'feeds_dashboard_show_operation',
    'page arguments' => array(1,4),
    'access callback' => 'feeds_access',
    'access arguments' => array('import', 1),
    'file' => 'feeds_dashboard.pages.inc',
  );
  $items['import/%feeds_importer/history/operation/%/revert'] = array(
    'title' => 'Operation',
    'type' => MENU_CALLBACK,
    'page callback' => 'feeds_dashboard_revert_operation',
    'page arguments' => array(1,4),
    'access callback' => 'feeds_access',
    'access arguments' => array('import', 1)
  );
  $items['import/%feeds_importer/history/operation/%/%'] = array(
    'title' => 'Operation content',
    'type' => MENU_CALLBACK,
    'page callback' => 'feeds_dashboard_show_operation_content',
    'page arguments' => array(1,4,5),
    'access callback' => 'feeds_access',
    'access arguments' => array('import', 1),
    'file' => 'feeds_dashboard.pages.inc',
  );

  return $items;
}

/**
 * Invoked before a feed source import starts.
 *
 * @param FeedsSource $source
 *  FeedsSource object that describes the source that is going to be imported.
 */
function feeds_dashboard_feeds_before_import(FeedsSource $source) {
  // Create log in database and get dashboard id.
  $source->did = db_insert('feeds_dashboard')
    ->fields(array(
      'operation_description' => 'Started importing.',
      'id' => $source->id,
      'file' => '',
      'date' => date('Y-m-d H:i:s'),
    ))
    ->execute();

  // Set variable using $source_id
  // since there can only be one
  // import at a time.
  variable_set($source->id, $source->did);
}

/**
 * Invoked after a feed source has been imported.
 *
 * @param FeedsSource $source
 *  FeedsSource object that describes the source that has been imported.
 */
function feeds_dashboard_feeds_after_import(FeedsSource $source) {
  // Delete temp variable.
  $did = variable_get($source->id);

  // Copy the source file to specific folder for history purpose.
  $file = file_load($source->config['FeedsFileFetcher']['fid']);
  $destination = drupal_realpath('public://') . '/feeds_dashboard/';

  if (file_prepare_directory($destination, FILE_CREATE_DIRECTORY)) {
    $destination = file_stream_wrapper_uri_normalize('public://feeds_dashboard/' . drupal_basename($file));
    $copied_file = file_copy($file, $destination, FILE_EXISTS_RENAME);

    // Log the import.
    if(!empty($copied_file)) {
      $results = $source->state['process'];
      $operation_description = t('@skipped skipped, @created created, @updated updated, @deleted deleted.', array('@skipped' => $results->skipped, '@created' => $results->created, '@updated' => $results->updated, '@deleted' => $results->deleted));

      db_update('feeds_dashboard')
        ->fields(array(
          'operation_description' => $operation_description,
          'file' => $copied_file->uri,
          'date' => date('Y-m-d H:i:s'),
        ))
        ->condition('did', $did, '=')
        ->execute();
    } else {
      drupal_set_message(t("Error while copying import file, please check file writing permission to public:// folder"), 'error', FALSE);
    }
  } else {
    drupal_set_message(t("Error while creating import folder, please check file writing permission to public:// folder"), 'error', FALSE);
  }

  // Delete temp variable.
  variable_del($source->id);
}


/**
 * Invoked after a feed source has been cleared of its items.
 *
 * @param FeedsSource $source
 *  FeedsSource object that describes the source that has been cleared.
 */
function feeds_dashboard_feeds_after_clear(FeedsSource $source) {
  // Log feed deletion.
  $results = $source->state['process_clear'];
  $operation_description = t('<span class="fd-content-clear">Feed content clear</span>: @skipped skipped, @created created, @updated updated, @deleted deleted.', array('@skipped' => $results->skipped, '@created' => $results->created, '@updated' => $results->updated, '@deleted' => $results->deleted));

  db_insert('feeds_dashboard')
    ->fields(array(
      'id' => $source->id,
      'operation_description' => $operation_description,
      'date' => date('Y-m-d H:i:s'),
    ))
    ->execute();
}

/**
 * Implements hook_node_delete().
 */
function feeds_dashboard_node_delete($node) {
  db_update('feeds_dashboard_operations')
    ->fields(array(
      'entity_id' => -1, // -1 is deleted.
      'state' => 'deleted'
    ))
    ->condition('entity_id', $node->nid, '=')
    ->execute();
}

/**
 * Invoked after a feed item has been saved.
 *
 * @param FeedsSource $source
 *  FeedsSource object that describes the source that is being imported.
 * @param $entity
 *   The entity object that has just been saved.
 * @param array $item
 *   The parser result for this entity.
 * @param int|null $entity_id
 *  The id of the current item which is going to be updated. If this is a new
 *  item, then NULL is passed.
 */
function feeds_dashboard_feeds_after_save(FeedsSource $source, $entity, $item, $entity_id) {
  $did = variable_get($source->id);

  // State of content.
  $state = 'created';
  if($entity->feeds_item->is_new === FALSE) {
    $state = 'updated';
  }
  
  // Log created content.
  db_insert('feeds_dashboard_operations')
    ->fields(array(
      'did' => $did,
      'entity' => serialize($entity),
      'content' => serialize($item),
      'state' => $state,
      'entity_id' => $entity->nid,
    ))
    ->execute();
}

/**
 * Implements hook_theme().
 */
function feeds_dashboard_theme() {
  $theme_subfolder = drupal_get_path('module', 'feeds_dashboard') . '/theme';
  $items['feeds_dashboard_history_page'] = array(
    'variables' => array('operations' => array()),
    'path' => $theme_subfolder,
    'template' => 'feeds-dashboard--history',
  );
  $items['feeds_dashboard_details'] = array(
    'variables' => array('data' => array()),
    'path' => $theme_subfolder,
    'template' => 'feeds-dashboard--table',
  );

  return $items;
}


/**
 * Returns an array of operations given a feed id.
 *
 * @param string $id
 *   Id of the feed configuration.
 */
function feeds_dashboard_get_operations_for_feed($id) {
  $operations = db_select('feeds_dashboard', 'fd')
    ->fields('fd')
    ->condition('id', $id, '=')
    ->orderBy('date', 'DESC')
    ->execute()
    ->fetchAllAssoc('did');

  return $operations;
}

/**
 * Returns an operation given an operation id.
 *
 * @param int $did
 *   operation id.
 */
function feeds_dashboard_get_operation($did) {
  $operation = db_select('feeds_dashboard', 'fd')
    ->fields('fd')
    ->condition('did', $did, '=')
    ->execute()
    ->fetchAllAssoc('did');

  return $operation;
}

/**
 * Returns import data given an import id.
 *
 * @param int $imid
 *   import id.
 */
function feeds_dashboard_get_imported_data($imid) {
  $data = db_select('feeds_dashboard_operations', 'fdo')
    ->fields('fdo')
    ->condition('imid', $imid, '=')
    ->execute()
    ->fetchAssoc();

  return $data;
}

/**
 * Returns an array of imported content
 * given an operation id.
 *
 * @param string $did
 *   Id of the operation.
 */
function feeds_dashboard_get_data_for_operation($did) {
  $data = db_select('feeds_dashboard_operations', 'fdo')
    ->fields('fdo')
    ->condition('did', $did, '=')
    ->orderBy('imid', 'ASC')
    ->execute()
    ->fetchAllAssoc('imid');

  return $data;
}

/**
 * Deletes revisions for a specific operation
 * given an operation id.
 *
 * @param FeedsImporter $feed
 *   Feed configuration.
 * @param string $did
 *   Id of the operation.
 * @param bool $confirm
 *   Used to display confirmation page, if $confirm is
 *   TRUE, the revert will be launched.
 */
function feeds_dashboard_revert_operation(FeedsImporter $feed_importer, $did, $confirm = '') {
  $data = feeds_dashboard_get_data_for_operation($did);

  if(!empty($data)) {
    // Confirm screen.
    $output = t("The following revisions are about to be deleted:");
    $list = array();

    // Display revisions which are about to be deleted.
    foreach ($data as $imid => $row) {
      $entity = unserialize($row->entity);
      $list['items'][] = l($entity->title, $entity->feeds_item->entity_type . '/' . $entity->feeds_item->entity_id . '/revisions/' . $entity->vid . '/view');
    }

    $output .= theme('item_list', $list);
    $output .= l(t("Confirm"), current_path() . "/confirm", array('attributes' => array('class' => 'button')));

    if($confirm === '') {
      return $output;
    }
    if($confirm === 'confirm') {
      $success = $error = 0;
      // Delete latest revision.
      foreach ($data as $imid => $row) {
        $entity = unserialize($row->entity);
        $state = feeds_dashboard_node_revision_revert($entity);

        // Update operation table with state.
        if($state !== FALSE) {
          db_update('feeds_dashboard_operations')
            ->fields(array(
              'state' => 'deleted'
            ))
            ->condition('did', $did, '=')
            ->execute();
          $success += 1;
        }
      }

      if($error > 0) {
        drupal_set_message(t("@success revisions were successfully deleted, @error revisions couldn't be deleted", array('@success' => $success, '@error' => $error)), 'warning', FALSE);
      } else {
        drupal_set_message(t("@success revisions were successfully deleted.", array('@success' => $success, '@error' => $error)), 'status', FALSE);
      }

      // Go back to dashboard.
      drupal_goto('import/' . arg(1) . '/history');
    }
  }
  return t("No data for this operation.");
}


/**
 * Revert a node to previous revision.
 *
 * @param Entity $entity
 *   Entity object to revert.
 */
function feeds_dashboard_node_revision_revert(&$entity) {
  if($entity->feeds_item->entity_type == 'node') {
    // Try to delete revision, node_revision_delete()
    // will return FALSE if revision is current.
    if (node_revision_delete($old_vid) !== FALSE) {
      return TRUE;
    } else {
      // If we can't delete the revision, we have
      // to find the second most recent revision
      // and duplicate it into our new on in order 
      // to revert to it.
      $revision_list = node_revision_list($entity);
      $old_vid = $entity->vid;
      unset($revision_list[$entity->vid]);

      // If multiple revisions revert to last.
      if (count($revision_list) > 0) {
        $last_revision = max(array_keys($revision_list));
        $entity = entity_revision_load('node', $last_revision);
        $entity->log = "Reverted via revert feed.";
        $saved = entity_save('node', $entity);

        // Invalidate hash.
        db_update('feeds_item')
          ->fields(array(
            'hash' => 'invalidated'
          ))
          ->condition('entity_id', $entity->nid)
          ->execute();

        if($saved !== FALSE) {
          // Delete previous revision now that 
          // we have saved the new one.
          if(node_revision_delete($old_vid) !== FALSE) {
            return TRUE;
          } else {
            return FALSE;
          }
        } else {
          return FALSE;
        }
      } else {
        return entity_delete('node', $entity->nid);
      }
    }
  } else {
    drupal_set_message(t("Couldn't revert, some entities are not nodes."), 'error', FALSE);
  }
  return FALSE;
}